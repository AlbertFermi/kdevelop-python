#!/usr/bin/env python

# Transforms a conversion definition file (.sdef) into C++ code. To be copied over manually. :)
# sdef example line:
# RULE_FOR _stmt;KIND Expr_kind;ACTIONS create|ExpressionAst set|value->ExpressionAst,value;CODE;;

contents = open('python26.sdef').read().replace("\n", "").split(';;')

func_structure = '''
    Ast* visitNode(%{RULE_FOR}* node) {
        switch ( node->kind ) {
%{SWITCH_LINES}
        default:
            kWarning() << "Unsupported statement AST type: " << node->kind;
            Q_ASSERT(false);
        }
    }
'''

switch_line = '''        case %{KIND}: {
%{ACTIONS}
                return v;
            }'''

create_ast_line = '''                %{AST_TYPE}* v = new %{AST_TYPE}(parent());'''
create_identifier_line = '''                v->attribute = new Python::Identifier(PyString_AsString(PyObject_Str(node->v.%{KIND_W/O_SUFFIX}.%{VALUE})));'''
set_attribute_line = '''                v->%{TARGET} = dynamic_cast<%{AST_TYPE}*>(visitNode(node->v.%{KIND_W/O_SUFFIX}.%{VALUE}));'''
resolve_list_line = '''                v->%{TARGET} = visitNodeList<%{PYTHON_AST_TYPE}>(node->v.%{KIND_W/O_SUFFIX}.%{VALUE});'''

results = dict()

def pluginAstToPythonAstType(plugintypestr):
    if plugintypestr == 'ExpressionAst': return '_expr'
    if plugintypestr == 'StatementAst' : return '_stmt'
    if plugintypestr == 'Ast': return '_node' # not sure about this
    else: return '<ERROR>'

for rule in contents:
    outline = rule.split(';')
    command = outline[0]
    if command[:7] == 'COMMENT' or command == '':
        continue
    elif command[:7] != 'RULE_FO':
        raise SyntaxError('Invalid syntax in sdef file, line: ' + rule)
    
    rule_for = outline[0].split(' ')[1]
    kind = outline[1].split(' ')[1]
    kind_wo_suffix = kind.replace('_kind', '')
    actions = outline[2].split(' ')[1:]
    
    if not results.has_key(rule_for):
        results[rule_for] = list()
    
    current_actions = list()
    for action in actions:
        command = action.split('|')[0]
        try:
            arguments = action.split('|')[1]
        except IndexError:
            continue
        action = '<ERROR>'
        if command == 'set':
            s = arguments.split('>')
            commandType = s[0][-1] # -, ~ or =
            target = s[0][:-1]
            s = s[1].split(',')
            raw = False

            if commandType == '~':
                raw = create_identifier_line
                value = s[0]
            else:
                astType = s[0]
                value = s[1]
                if commandType == '=':
                    raw = resolve_list_line
                if commandType == '-':
                    raw = set_attribute_line
            
            if raw:
                command = raw.replace('%{AST_TYPE}', astType).replace('%{TARGET}', target) \
                             .replace('%{PYTHON_AST_TYPE}', pluginAstToPythonAstType(astType)) \
                             .replace('%{KIND_W/O_SUFFIX}', kind_wo_suffix).replace('%{VALUE}', value)
            
            current_actions.append(command)
            
        elif command == 'create':
            astType = arguments
            current_actions.append(create_ast_line.replace('%{AST_TYPE}', astType))
    
    current_actions = "\n".join(current_actions)
    current_stmt = switch_line.replace('%{KIND}', kind_wo_suffix).replace('%{ACTIONS}', current_actions)
    results[rule_for].append(current_stmt)

print '''/* This file is generated by conversiongenerator.py.
 * I do not recommend editing it.
 */

#ifndef PYTHONASTTRANSFORMER_H
#define PYTHONASTTRANSFORMER_H

#include <python2.6/pyport.h>
#include <python2.6/pyconfig.h>
#include <python2.6/node.h>

#include <python2.6/Python.h>

#include <python2.6/Python-ast.h>
#include <python2.6/ast.h>

#include <python2.6/graminit.h>
#include <python2.6/grammar.h>
#include <python2.6/parsetok.h>

#include <python2.6/object.h>

#include "ast.h"

#undef test
#undef decorators
#undef Attribute

namespace Python
{
    
class PythonAstTransformer {
public:
    CodeAst* ast;
    void run(mod_ty syntaxtree) {
        ast = new CodeAst();
        nodeStack.push(ast);
        ast->body = visitNodeList<_stmt>(syntaxtree->v.Module.body);
    }
private:
    QStack<Ast*> nodeStack;
    
    Ast* parent() {
        return nodeStack.top();
    }
    
    template<typename T> QList<T*> visitNodeList(asdl_seq* node) {
        QList<T*> nodelist;
        for ( int i=0; i < node->size; i++ ) {
            T* currentNode = reinterpret_cast<T*>(node->elements[i]);
            Q_ASSERT(currentNode);
            nodelist.append(visitNode(currentNode));
        }
        return nodelist;
    }

'''

for index, lines in results.iteritems():
    current_switch_lines = "\n".join(lines)
    func = func_structure.replace('%{RULE_FOR}', index).replace('%{SWITCH_LINES}', current_switch_lines)
    print func

print '''};

#endif'''
