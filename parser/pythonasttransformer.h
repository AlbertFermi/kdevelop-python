/* This file is generated by conversiongenerator.py.
 * I do not recommend editing it.
 */

#ifndef PYTHONASTTRANSFORMER_H
#define PYTHONASTTRANSFORMER_H

#include <python2.6/pyport.h>
#include <python2.6/pyconfig.h>
#include <python2.6/node.h>

#include <python2.6/Python.h>

#include <python2.6/Python-ast.h>
#include <python2.6/ast.h>

#include <python2.6/graminit.h>
#include <python2.6/grammar.h>
#include <python2.6/parsetok.h>

#include <python2.6/object.h>

#include "ast.h"

#undef test
#undef decorators
#undef Attribute

namespace Python
{
    
class PythonAstTransformer {
public:
    CodeAst* ast;
    void run(mod_ty syntaxtree) {
        ast = new CodeAst();
        nodeStack.push(ast);
        ast->body = visitNodeList<_stmt>(syntaxtree->v.Module.body);
    }
private:
    QStack<Ast*> nodeStack;
    
    Ast* parent() {
        return nodeStack.top();
    }
    
    template<typename T> QList<T*> visitNodeList(asdl_seq* node) {
        QList<T*> nodelist;
        for ( int i=0; i < node->size; i++ ) {
            T* currentNode = reinterpret_cast<T*>(node->elements[i]);
            Q_ASSERT(currentNode);
            nodelist.append(visitNode(currentNode));
        }
        return nodelist;
    }



    Ast* visitNode(_stmt* node) {
        switch ( node->kind ) {
        case Expr: {
                ExpressionAst* v = new ExpressionAst(parent());
                v->value = dynamic_cast<ExpressionAst*>(visitNode(node->v.Expr.value));
                return v;
            }
        case FunctionDef: {
                FunctionDefinitionAst* v = new FunctionDefinitionAst(parent());
                v->arguments = dynamic_cast<ArgumentsAst*>(visitNode(node->v.FunctionDef.args));
                v->body = visitNodeList<_node>(node->v.FunctionDef.body);
                v->decorators = visitNodeList<_expr>(node->v.FunctionDef.decorator_list);
                v->attribute = new Python::Identifier(PyString_AsString(PyObject_Str(node->v.FunctionDef.name)));
                return v;
            }
        case ClassDef: {
                ClassDefinitionAst* v = new ClassDefinitionAst(parent());
                v->baseClasses = visitNodeList<_expr>(node->v.ClassDef.bases);
                v->body = visitNodeList<_node>(node->v.ClassDef.body);
                v->decorators = visitNodeList<_expr>(node->v.ClassDef.decorator_list);
                v->attribute = new Python::Identifier(PyString_AsString(PyObject_Str(node->v.ClassDef.name)));
                return v;
            }
        default:
            kWarning() << "Unsupported statement AST type: " << node->kind;
            Q_ASSERT(false);
        }
    }

};

#endif
